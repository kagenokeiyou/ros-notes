# 动作（Action）

在 ROS 2 中，一个 action 指的是具有反馈和可取消或抢占目标的长时间运行的远程过程调用。例如，运行机器人的高级状态机可能会调用一个 action 来告诉导航子系统前往一个航点，这可能需要几秒钟（或几分钟）的时间。在过程中，导航子系统可以提供关于其进展的反馈，而高级状态机可以选择取消或抢占前往该航点的行程。

这种结构体现在 action 消息定义的样式中：

```rosmsg
int32 request
---
int32 response
---
int32 feedback
```

在 ROS 2 中，actions 预期是长时间运行的过程，因为在建立和监控连接时有开销。如果你需要一个短时间运行的远程过程调用，可以考虑使用服务。

Actions 通过一个 action 名称来标识，它看起来很像一个主题名称（但在不同的命名空间中）。

一个动作由两部分组成：动作服务器和动作客户端。

## 接口定义

动作是一种长时间运行的请求/响应通信，其中动作客户端（请求者）等待动作服务器（响应者）执行某些操作并返回结果。与服务不同，动作可以长时间运行（许多秒或分钟），在执行过程中提供反馈，并且可以被中断。

动作定义具有以下形式：

```rosmsg
<request_type> <request_fieldname>
---
<response_type> <response_fieldname>
---
<feedback_type> <feedback_fieldname>
```

与服务类似，请求字段位于第一个三连破折号（`---`）之前，响应字段位于其之后。在第二个三连破折号之后还有第三组字段，这些字段是在发送反馈时发送的字段。

可以有任意数量的请求字段（包括零个），任意数量的响应字段（包括零个），以及任意数量的反馈字段（包括零个）。

`<request_type>` 、 `<response_type>` 和 `<feedback_type>` 遵循消息 `<type>` 的所有相同规则。 `<request_fieldname>` 、 `<response_fieldname>` 和 `<feedback_fieldname>` 遵循消息 `<fieldname>` 的所有相同规则。

例如， `Fibonacci` 动作定义包含以下内容

```rosmsg
int32 order
---
int32[] sequence
---
int32[] sequence
```

这是一个动作定义，其中动作客户端发送一个 `int32` 字段来表示要执行的斐波那契步骤数，并期望动作服务器生成一个 `int32` 数组来包含完整的步骤。在过程中，动作服务器还可能提供一个 `int32` 中间数组，其中包含到某个特定点为止已完成的步骤。

## 动作服务器

动作服务器是接收远程过程请求并在其上执行某些操作的实体。它还负责在动作进行时发送反馈，并应对取消/抢占请求。例如，考虑一个计算斐波那契序列的动作，其接口如下：

```rosmsg
int32 order
---
int32[] sequence
---
int32[] sequence
```

动作服务器接收此消息，开始计算序列直到 order （提供沿途的反馈），最后在 sequence 返回完整结果。

> [!Note]
> 每个动作名称下应该只有一个动作服务器。当同一个动作名称存在多个动作服务器时，无法确定哪个动作服务器会接收客户端请求。

## 动作客户端

动作客户端是一个请求远程动作服务器代表其执行操作的实体。根据上述示例，动作客户端是创建包含 order 的初始消息的实体，并等待动作服务器计算序列并返回结果（过程中可能包含反馈）。

与动作服务器不同，使用同一个动作名称的动作客户端可以有任意数量。
